import logging
import asyncio

from NetUtils import ClientStatus, color
from worlds.AutoSNIClient import SNIClient
from .locations import loc_id_start
from .items import item_table, arch_item_offset
from .rom import crystal_ram_data, magic_ram_data, ability_ram_data, item_ram_data, key_item_data
from .ram_watch_util import address_to_ram, ram_to_address, full_flag_dict

snes_logger = logging.getLogger("SNES")

# FXPAK Pro protocol memory mapping used by SNI
ROM_START = 0x000000
WRAM_START = 0xF50000
WRAM_SIZE = 0x20000
SRAM_START = 0xE00000

FFVCD_ROMNAME_START = 0x00FFC0
FFVCD_ROMHASH_START = 0x7FC0
ROMNAME_SIZE = 0x15
ROMHASH_SIZE = 0x15


FFVCD_EVENT_FLAG_ADDR = WRAM_START + 0x000A14
FFVCD_EVENT_FLAG_BRBLADE_CHKN_ADDR = WRAM_START + 0x001443
FFVCD_CHESTS_ADDR = WRAM_START + 0x0009D4
FFVCD_IN_MENU_FLAG_ADDR = WRAM_START + 0x00014B
FFVCD_IN_MENU_FLAG2_ADDR = WRAM_START + 0x00020D
FFVCD_IN_MENU_FLAG3_ADDR = WRAM_START + 0x000B45 # this is tied to screen visibility fade in/out
FFVCD_IN_BATTLE_FLAG_ADDR = WRAM_START + 0x00014D


FFVCD_RECV_PROGRESS_ADDR = WRAM_START + 0x9F4
FFVCD_FILE_NAME_ADDR = WRAM_START + 0x5D9



class FFVCDSNIClient(SNIClient):
    game = "Final Fantasy V Career Day"
    async def deathlink_kill_player(self, ctx):
        pass
        # FFVCD_TODO: Handle Receiving Deathlink


    async def validate_rom(self, ctx):
        # #print("Validating FFVCD rom")
        from SNIClient import snes_buffered_write, snes_flush_writes, snes_read

        rom_name = await snes_read(ctx, FFVCD_ROMHASH_START, ROMHASH_SIZE)
        
        # #print("rom_name: %s" % rom_name)
        # if rom_name:
            # #print("rom_name[:2]: %s" % (str(rom_name)[:2]))

        if rom_name is None or rom_name == bytes([0] * ROMHASH_SIZE) or rom_name[:2] != b"K7":
            # #print("Fail validate_rom")
            return False
        
        # #print("Pass validate_rom")
        ctx.game = self.game
        ctx.items_handling = 0b111  # remote items

        ctx.rom = rom_name
        return True


    async def game_watcher(self, ctx):
        from SNIClient import snes_buffered_write, snes_flush_writes, snes_read
        
        ##############
        # EVENTS
        ##############
        d1 = await snes_read(ctx, FFVCD_EVENT_FLAG_ADDR, 0x100)
        # import pickle
        # with open('pickle.p', 'wb') as f:
        #     pickle.dump(d, f)

            
        ram_dict = {} 
        start = 'A14'
        for idx, entry in enumerate(d1):
            x1 = hex(int(str(start),base=16) + idx).replace("0x","").upper()
            if len(x1) == 3:
                x1 = "0%s" % x1
            ram_dict[x1] =    hex(entry).replace("0x","").upper()
        for k, v in ram_dict.items():
            if len(v) == 1:
                ram_dict[k] = "0%s" % v


        ##############
        # CHESTS
        ##############
        d3 = await snes_read(ctx, FFVCD_CHESTS_ADDR, 0x40)


        start = '9D4'
        for idx, entry in enumerate(d3):
            x1 = hex(int(str(start),base=16) + idx).replace("0x","").upper()
            if len(x1) == 3:
                x1 = "0%s" % x1
            ram_dict[x1] =    hex(entry).replace("0x","").upper()
        for k, v in ram_dict.items():
            if len(v) == 1:
                ram_dict[k] = "0%s" % v
                
                
                    
            

        # import pickle
        # with open('pickle.p', 'wb') as f:
        #     pickle.dump(d4, f)

                
                
                
        def check_status_bits(ram_bit, loc_bit, direction):
            if direction == "ON":
                return int(ram_bit, base=16) & int(loc_bit, base=16) != 0
            elif direction == "OFF":
                return int(ram_bit, base=16) & int(loc_bit, base=16) == 0
                
                
        def hex_or_return_int(a, b):
            return min(int(a,base=16) | int(b, base=16), 255)
        def hex_xor_return_int(a, b):
            return min(int(a,base=16) ^ int(b, base=16), 255)
        def hex_and_return_int(a, b):
            return min(int(a,base=16) & int(b, base=16), 255)
                
                
        def convert_int_to_two_bytes_as_list(i):
            return [i % 256, i // 256]
        def convert_two_bytes_to_int(a, b):
            return a + b * 256
        
    
        

        ####################            
        # CHECKS TO ALLOW RECEIVING
        ####################
        in_menu_flag = await snes_read(ctx, FFVCD_IN_MENU_FLAG_ADDR, 0x1)
        in_menu_flag2 = await snes_read(ctx, FFVCD_IN_MENU_FLAG2_ADDR, 0x1)
        in_menu_flag3 = await snes_read(ctx, FFVCD_IN_MENU_FLAG3_ADDR, 0x1)
        if in_menu_flag is None:
            return
        elif in_menu_flag[0] == 0x00 or in_menu_flag2[0] != 0xF0 or in_menu_flag3[0] < 0xF0:
            # if 0x00014B == 0x00, do not allow (this is nonzero when in a menu)
            print("In a menu, waiting to receive...")
            return
        
        in_battle_flag = await snes_read(ctx, FFVCD_IN_BATTLE_FLAG_ADDR, 0x1)
        if in_battle_flag is None:
            return
        elif in_battle_flag[0] == 0x10:
            # if 0x00014D == 0x10, do not allow (this is set to 0x10 when in battle)
            print("In a battle, waiting to receive...")
            return

        # loaded_game_flag1 = await snes_read(ctx, WRAM_START, 0x1)
        loaded_game_flag2 = await snes_read(ctx, WRAM_START + 0x30, 0x1)
        loaded_game_flag3 = await snes_read(ctx, WRAM_START + 0x6F, 0x1)
        if loaded_game_flag2 is None:
            return
        elif loaded_game_flag2[0] != 0x00 or loaded_game_flag3[0] != 0x00:
            # if any of these three addresses near the top of memory aren't zero, disallow
            print("0x7E0000/30/6F are non zero, game likely not loaded, waiting to receive...")
            return

        
        
        
        
        
        
        
        

        new_checks = []
        for event_flag_addr, event_flag_data in full_flag_dict.items():
            try:
                ram_byte = event_flag_data['byte']
                ram_bit = ram_dict[ram_byte]
                loc_bit = event_flag_data['bit']
                direction = event_flag_data['direction']
                loc_id = int(event_flag_addr,base=16) + loc_id_start
                
                if event_flag_addr == "C0FFFF":
                    status1 = check_status_bits(ram_bit, '01', direction)
                    status2 = check_status_bits(ram_bit, '02', direction)
                    status3 = check_status_bits(ram_bit, '04', direction)
                    if status1 and status2 and status3:
                        status = True
                    else:
                        status = False
                else:
                    status = check_status_bits(ram_bit, loc_bit, direction)
                if loc_id not in ctx.locations_checked and status:
                    new_checks.append(loc_id)
                # #print("%s%s" % ("{:<60}".format(event_flag_data['name']), status))
            except Exception as e:
                pass
                # print(e)    
                

        for new_check_id in new_checks:
            ctx.locations_checked.add(new_check_id)
            location = ctx.location_names[new_check_id]
            snes_logger.info(
                f'New Check: {location} ({len(ctx.locations_checked)}/{len(ctx.missing_locations) + len(ctx.checked_locations)})')
            await ctx.send_msgs([{"cmd": 'LocationChecks', "locations": [new_check_id]}])

        recv_count = await snes_read(ctx, FFVCD_RECV_PROGRESS_ADDR, 2)
        recv_index = convert_two_bytes_to_int(recv_count[0], recv_count[1])

        print("recv_index %s -> items_received %s" % (recv_index, len(ctx.items_received)))
        if recv_index < len(ctx.items_received):
            item = ctx.items_received[recv_index]
            recv_index += 1
            logging.info('Received %s from %s (%s) (%d/%d in list)' % (
                color(ctx.item_names[item.item], 'red', 'bold'),
                color(ctx.player_names[item.player], 'yellow'),
                ctx.location_names[item.location], recv_index, len(ctx.items_received)))

            recv_index_list = convert_int_to_two_bytes_as_list(recv_index)
            #print("Writing bytes recv_index %s to %s -> %s" % (FFVCD_RECV_PROGRESS_ADDR, recv_index_list, bytes(recv_index_list)))
            snes_buffered_write(ctx, FFVCD_RECV_PROGRESS_ADDR, bytes(recv_index_list))
            
            arch_item_id = item.item - arch_item_offset
            #print(arch_item_id)
            
            #print("This game's slot %s -> item player %s" % (ctx.slot, item.player))
            

            ####################            
            # RECEIVE CRYSTALS
            ####################
            


            if arch_item_id == 1200:
                # Handle Victory
                if not ctx.finished_game:
                    await ctx.send_msgs([{"cmd": "StatusUpdate", "status": ClientStatus.CLIENT_GOAL}])
                    ctx.finished_game = True


            ####################            
            # RECEIVE CRYSTALS
            ####################
            
            if arch_item_id in crystal_ram_data.keys():
                crystal_data = crystal_ram_data[arch_item_id]
                crystal_data_bit, crystal_data_ram_addr = crystal_data
                
                current_bit = await snes_read(ctx, WRAM_START + crystal_data_ram_addr, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), crystal_data_bit)
                snes_buffered_write(ctx, WRAM_START + crystal_data_ram_addr, bytes([new_bit]))
                #print("Write crystal")
                    
            ####################            
            # RECEIVE MAGIC
            ####################
            
            if arch_item_id in magic_ram_data.keys():
                magic_data = magic_ram_data[arch_item_id]
                magic_data_bit, magic_data_ram_addr = magic_data
                
                current_bit = await snes_read(ctx, WRAM_START + magic_data_ram_addr, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), magic_data_bit)
                snes_buffered_write(ctx, WRAM_START + magic_data_ram_addr, bytes([new_bit]))
                #print("Write magic")
                    
            ####################            
            # RECEIVE ABILITY
            ####################
            
            if arch_item_id in ability_ram_data.keys():
                ability_data = ability_ram_data[arch_item_id]
                ability_data_bit, ability_data_ram_addr = ability_data
                
                current_bit = await snes_read(ctx, WRAM_START + ability_data_ram_addr, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), ability_data_bit)
                snes_buffered_write(ctx, WRAM_START + ability_data_ram_addr, bytes([new_bit]))
                #print("Write ability 1")

                current_bit = await snes_read(ctx, WRAM_START + ability_data_ram_addr + 0x14, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), ability_data_bit)
                snes_buffered_write(ctx, WRAM_START + ability_data_ram_addr + 0x14, bytes([new_bit]))
                #print("Write ability 2")

                current_bit = await snes_read(ctx, WRAM_START + ability_data_ram_addr + 0x28, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), ability_data_bit)
                snes_buffered_write(ctx, WRAM_START + ability_data_ram_addr + 0x28, bytes([new_bit]))
                #print("Write ability 3")

                current_bit = await snes_read(ctx, WRAM_START + ability_data_ram_addr + 0x3C, 0x01)
                new_bit = hex_or_return_int(hex(current_bit[0]), ability_data_bit)
                snes_buffered_write(ctx, WRAM_START + ability_data_ram_addr + 0x3C, bytes([new_bit]))
                #print("Write ability 4")
                    
            ##############
            # RECEIVE ITEMS
            ##############
            
            
            if arch_item_id in item_ram_data.keys():
                if ctx.slot == item.player:
                    pass
                    #print("Self item, skip")
                    
                else:
    
                    d4 = await snes_read(ctx, WRAM_START + 0x640, 0x100)
            
                    ram_current_item_map = {}
                    
                    for idx, i in enumerate(d4):
                        ram_current_item_map[idx] = hex(i).replace("0x","").upper()
                    
                    for k, v in ram_current_item_map.items():
                        if len(v) == 1:
                            ram_current_item_map[k] = "0%s" % v
                            
                    new_item_byte = item_ram_data[arch_item_id]
                    
                    match_idx = None
                    for k, v in ram_current_item_map.items():
                        if v == new_item_byte:
                            match_idx = k
                            break
                            
                    if match_idx:
                        # if a match was found, find its corresponding inventory count then add 1
                        item_count_in_inventory = await snes_read(ctx, WRAM_START + 0x740 + match_idx, 0x01)
                        item_count_in_inventory = min(item_count_in_inventory[0] + 1, 99)
                        snes_buffered_write(ctx, WRAM_START + 0x740 + match_idx, bytes([item_count_in_inventory]))
                    else:
                        # if a match was not found, find the first 00 slot in inventory ids, then assign it and give it 1 count
                        new_item_idx = None
                        for k, v in ram_current_item_map.items():
                            if v == '00':
                                new_item_idx = k
                                break
                        
                        if new_item_idx:
                            # this should always be true, or else something real bad is happening in inventory >_>;....
                            #print("Adding new item %s at %s" % (new_item_byte, WRAM_START + 0x640 + new_item_idx))
                            snes_buffered_write(ctx, WRAM_START + 0x640 + new_item_idx, bytes([int(new_item_byte,base=16)]))
                            snes_buffered_write(ctx, WRAM_START + 0x740 + new_item_idx, bytes([1]))
                        else:
                            pass
                            #print("Could not create for %s " % new_item_byte)


            ####################            
            # RECEIVE KEY ITEMS
            ####################
            
            if arch_item_id in key_item_data.keys():
                key_item_data_entries = key_item_data[arch_item_id]
                
                if arch_item_id != 1005 and arch_item_id != 1006:    
                    for key_item_data_entry in key_item_data_entries:
                        key_item_bit, key_item_addr_offset, key_item_direction = key_item_data_entry

                        current_bit = await snes_read(ctx, WRAM_START + 0xA00 + key_item_addr_offset, 0x01)
                        if key_item_direction == "ON":
                            new_bit = hex_or_return_int(hex(current_bit[0]), key_item_bit)
                        elif key_item_direction == "OFF":
                            new_bit = hex_xor_return_int(hex(current_bit[0]), key_item_bit)
                        else:
                            break
                            
                        snes_buffered_write(ctx, WRAM_START + 0xA00 + key_item_addr_offset, bytes([new_bit]))
                        #print("Write key item")

                elif arch_item_id == 1005 or arch_item_id == 1006:   # handle hiryuu / submarine
                    # first handle key item for menu text
                    key_item_bit, key_item_addr_offset, key_item_direction = key_item_data_entries[0]
                    current_bit = await snes_read(ctx, WRAM_START + 0xA00 + key_item_addr_offset, 0x01)
                    new_bit = hex_or_return_int(hex(current_bit[0]), key_item_bit)
                    snes_buffered_write(ctx, WRAM_START + 0xA00 + key_item_addr_offset, bytes([new_bit]))
                    #print("Write key item")
                    
                    # then handle coords writing
                    for key_item_data_entry in key_item_data_entries[1:]:
                        key_item_byte, key_item_addr_offset, key_item_direction = key_item_data_entry
                        snes_buffered_write(ctx, WRAM_START + 0xA00 + key_item_addr_offset, bytes([int(key_item_byte,base=16)]))
                        #print("Write key item")
                        
            await snes_flush_writes(ctx)
                    
                    
        return 
    
